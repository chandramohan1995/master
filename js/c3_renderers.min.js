(function() {
    (function(t) {
        "object" == typeof exports && "object" == typeof module ? t(require("jquery"), require("c3")) : "function" == typeof define && define.amd ? define(["jquery", "c3"], t) : t(jQuery, c3)
    })(function(t, e) {
        var n;
        return n = function(n) {
            return null == n && (n = {}),
                function(r, a) {
                    var o, l, i, u, s, c, h, g, p, d, f, y, x, v, b, j, m, z, w, k, A, C, S, q, B, H, _, F, K, T, L, N, Q, R, U, W, D, E, G, I, J, M, O, P, V, X, Y, Z, $, tt, et, nt, rt, at, ot, lt, it, ut;
                    if (p = {
                            localeStrings: {
                                vs: "vs",
                                by: "by"
                            },
                            c3: {}
                        }, null == (D = (a = t.extend(!0, {}, p, a)).c3).size && (D.size = {}), null == (E = a.c3.size).width && (E.width = window.innerWidth / 1.4), null == (G = a.c3.size).height && (G.height = window.innerHeight / 1.4 - 50), null == n.type && (n.type = "line"), null == n.horizontal && (n.horizontal = !1), null == n.stacked && (n.stacked = !1), 0 === (B = r.getRowKeys()).length && B.push([]), 0 === (c = r.getColKeys()).length && c.push([]), b = function() {
                            var t, e, n;
                            for (n = [], t = 0, e = c.length; t < e; t++) x = c[t], n.push(x.join("-"));
                            return n
                        }(), A = 0, f = r.aggregatorName, r.valAttrs.length && (f += "(" + r.valAttrs.join(", ") + ")"), "scatter" === n.type)
                        for (_ = {
                                x: {},
                                y: {},
                                t: {}
                            }, L = null != (ot = (l = r.rowAttrs.concat(r.colAttrs))[0]) ? ot : "", v = null != (lt = l[1]) ? lt : "", y = l.slice(2).join("-"), T = L, "" !== v && (T += " " + a.localeStrings.vs + " " + v), "" !== y && (T += " " + a.localeStrings.by + " " + y), V = 0, $ = B.length; V < $; V++)
                            for (q = B[V], X = 0, tt = c.length; X < tt; X++) s = c[X], null != (o = r.getAggregator(q, s)).value() && (Q = q.concat(s), "" === (F = Q.slice(2).join("-")) && (F = "series"), null == (I = _.x)[F] && (I[F] = []), null == (J = _.y)[F] && (J[F] = []), W = null != (it = Q[0]) ? it : 0, R = null != (ut = Q[1]) ? ut : 0, _.y[F].push(W), _.x[F].push(R), null == (M = _.t)[F] && (M[F] = {}), null == (O = _.t[F])[R] && (O[R] = {}), _.t[F][R][W] = o.value());
                    else {
                        for (j = 0, Y = 0, et = b.length; Y < et; Y++) j += (R = b[Y]).length;
                        for (j > 50 && (A = 45), h = [], Z = 0, nt = B.length; Z < nt; Z++) {
                            for (C = ["" === (S = (q = B[Z]).join("-")) ? f : S], at = 0, rt = c.length; at < rt; at++) s = c[at], N = parseFloat(r.getAggregator(q, s).value()), isFinite(N) ? C.push(N) : C.push(null);
                            h.push(C)
                        }
                        L = f, n.horizontal ? (v = r.rowAttrs.join("-"), y = r.colAttrs.join("-")) : (v = r.colAttrs.join("-"), y = r.rowAttrs.join("-")), T = f, "" !== v && (T += " " + a.localeStrings.vs + " " + v), "" !== y && (T += " " + a.localeStrings.by + " " + y)
                    }
                    if ((K = t("<p>", {
                            style: "text-align: center; font-weight: bold"
                        })).text(T), d = r.getAggregator([], []).format, z = {
                            axis: {
                                rotated: n.horizontal,
                                y: {
                                    label: L,
                                    tick: {}
                                },
                                x: {
                                    label: v,
                                    tick: {
                                        rotate: A,
                                        multiline: !1
                                    }
                                }
                            },
                            data: {
                                type: n.type,
                                order: null
                            },
                            tooltip: {
                                grouped: !1
                            },
                            color: {
                                pattern: ["#3366cc", "#dc3912", "#ff9900", "#109618", "#990099", "#0099c6", "#dd4477", "#66aa00", "#b82e2e", "#316395", "#994499", "#22aa99", "#aaaa11", "#6633cc", "#e67300", "#8b0707", "#651067", "#329262", "#5574a6", "#3b3eac"]
                            }
                        }, z = t.extend(!0, {}, z, a.c3), "scatter" === n.type) {
                        for (H in U = {}, m = 0, g = [], _.x) m += 1, U[H] = H + "_x", g.push([H + "_x"].concat(_.x[H])), g.push([H].concat(_.y[H]));
                        z.data.xs = U, z.data.columns = g, z.axis.x.tick = {
                            fit: !1
                        }, 1 === m && (z.legend = {
                            show: !1
                        }), z.tooltip.format = {
                            title: function() {
                                return f
                            },
                            name: function() {
                                return ""
                            },
                            value: function(t, e, n, r, a) {
                                var o;
                                return o = a[0], F = o.name, W = o.value, R = o.x, d(_.t[F][R][W])
                            }
                        }
                    } else z.axis.x.type = "category", null == (P = z.axis.y.tick).format && (P.format = function(t) {
                        return d(t)
                    }), z.tooltip.format = {
                        value: function(t) {
                            return d(t)
                        }
                    }, n.horizontal ? (1 === (u = function() {
                        var t, e, n;
                        for (n = [], e = 0, t = h.length; e < t; e++) i = h[e], n.push(i.shift());
                        return n
                    }()).length && u[0] === f && (u = [""]), z.axis.x.categories = u, 1 === b.length && "" === b[0] && (b = [f]), h.unshift(b), z.data.rows = h) : (z.axis.x.categories = b, z.data.columns = h);
                    return n.stacked && (n.horizontal ? z.data.groups = [function() {
                        var t, e, n;
                        for (n = [], e = 0, t = c.length; e < t; e++) R = c[e], n.push(R.join("-"));
                        return n
                    }()] : z.data.groups = [function() {
                        var t, e, n;
                        for (n = [], e = 0, t = B.length; e < t; e++) R = B[e], n.push(R.join("-"));
                        return n
                    }()]), w = t("<div>", {
                        style: "display:none;"
                    }).appendTo(t("body")), k = t("<div>").appendTo(w), z.bindto = k[0], e.generate(z), k.detach(), w.remove(), t("<div>").append(K, k)
                }
        }, t.pivotUtilities.c3_renderers = {
            "Horizontal Bar Chart": n({
                type: "bar",
                horizontal: !0
            }),
            "Horizontal Stacked Bar Chart": n({
                type: "bar",
                stacked: !0,
                horizontal: !0
            }),
            "Bar Chart": n({
                type: "bar"
            }),
            "Stacked Bar Chart": n({
                type: "bar",
                stacked: !0
            }),
            "Line Chart": n(),
            "Area Chart": n({
                type: "area",
                stacked: !0
            }),
            "Scatter Chart": n({
                type: "scatter"
            })
        }
    })
}).call(this);
